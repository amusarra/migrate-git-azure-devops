name: Go Release

permissions:
  contents: write
  packages: write
on:
  push:
    tags:
      - "*.*.*"
      - "*.*.*-*" # include pre-release tags

jobs:
  goreleaser:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # required for changelog

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25"

      - name: Setup GoReleaser
        uses: goreleaser/goreleaser-action@v6.4.0
        with:
          version: ~> v2
          args: release --clean
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  codesign:
    needs: goreleaser
    runs-on: windows-latest
    steps:
      - name: Download Windows assets from release
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $tag = "${{ github.ref_name }}"
          $repo = "${{ github.repository }}"
          $releaseDir = "$env:RUNNER_TEMP\release"
          New-Item -ItemType Directory -Path $releaseDir | Out-Null
          gh release download $tag --repo $repo --dir $releaseDir --pattern "*windows*"
          Get-ChildItem $releaseDir -Recurse | Format-List

        # In a real environment, use a valid certificate recognized by Microsoft
        # to avoid warnings for the end user.
      - name: Generate self-signed certificate (Code Sign)
        shell: pwsh
        run: |
          $certPath = "$env:RUNNER_TEMP\codesign.pfx"
          $certPass = "githubactions"
          $subject = "CN=GitHub Actions SelfSign, O=Antonio Musarra, C=IT"
          $cert = New-SelfSignedCertificate -Type CodeSigningCert -Subject $subject -CertStoreLocation "Cert:\CurrentUser\My" -KeyExportPolicy Exportable -KeySpec Signature
          Export-PfxCertificate -Cert $cert -FilePath $certPath -Password (ConvertTo-SecureString -String $certPass -Force -AsPlainText)
          Write-Host "Certificate generated: $certPath"

      - name: Find signtool.exe path
        id: signtool
        shell: pwsh
        run: |
          $signtool = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin\" -Recurse -Filter signtool.exe | Where-Object { $_.FullName -like "*x64*" } | Select-Object -First 1
          if (-not $signtool) {
            Write-Error "signtool.exe not found!"
            exit 1
          }
          echo "signtool_path=$($signtool.FullName)" >> $env:GITHUB_ENV

      - name: Sign .exe (standalone and inside zip)
        shell: pwsh
        run: |
          $certPath = "$env:RUNNER_TEMP\codesign.pfx"
          $certPass = "githubactions"
          $releaseDir = "$env:RUNNER_TEMP\release"
          $signtool = "${env:signtool_path}"

          function Sign-Exe($exePath) {
            & "$signtool" sign /fd SHA256 /f "$certPath" /p "$certPass" /tr http://timestamp.digicert.com /td SHA256 "$exePath"
          }

          # Sign standalone .exe
          Get-ChildItem $releaseDir -Filter *.exe -Recurse | ForEach-Object {
            Write-Host "Signing $_"
            Sign-Exe $_.FullName
          }

          # Sign .exe inside zip
          Get-ChildItem $releaseDir -Filter *.zip | ForEach-Object {
            $zip = $_.FullName
            $work = Join-Path $env:RUNNER_TEMP ([IO.Path]::GetFileNameWithoutExtension($_.Name))
            if (Test-Path $work) { Remove-Item $work -Recurse -Force }
            Expand-Archive -Path $zip -DestinationPath $work -Force

            Get-ChildItem $work -Recurse -Filter *.exe | ForEach-Object {
              Write-Host "Signing $_"
              Sign-Exe $_.FullName
            }

            Remove-Item $zip -Force
            Compress-Archive -Path (Get-ChildItem $work) -DestinationPath $zip
          }

      - name: Re-upload signed assets (clobber)
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $tag = "${{ github.ref_name }}"
          $repo = "${{ github.repository }}"
          $releaseDir = "$env:RUNNER_TEMP\release"

          $exeFiles = Get-ChildItem -Path $releaseDir -Recurse -Filter *.exe | Select-Object -ExpandProperty FullName
          if ($exeFiles) {
            gh release upload $tag $exeFiles --repo $repo --clobber
          } else {
            Write-Host "No .exe files found for upload"
          }

          $zipFiles = Get-ChildItem -Path $releaseDir -Recurse -Filter *.zip | Select-Object -ExpandProperty FullName
          if ($zipFiles) {
            gh release upload $tag $zipFiles --repo $repo --clobber
          } else {
            Write-Host "No .zip files found for upload"
          }

  codesign-macos:
    needs: goreleaser
    runs-on: macos-latest
    steps:
      - name: Download macOS assets from release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          tag="${{ github.ref_name }}"
          repo="${{ github.repository }}"
          releaseDir="$RUNNER_TEMP/release"
          mkdir -p "$releaseDir"
          gh release download "$tag" --repo "$repo" --dir "$releaseDir" --pattern "*darwin*"
          ls -l "$releaseDir"

      - name: Generate self-signed certificate (Code Sign)
        run: |
          CERT_NAME="GitHub Actions SelfSign"
          CERT_FILE="$RUNNER_TEMP/codesign-cert.p12"
          CERT_PASS="githubactions"
          TMP_KEYCHAIN="$RUNNER_TEMP/codesign.keychain-db"
          # Crea file di configurazione OpenSSL per codeSigning
          cat > codesign.cnf <<EOF
          [ req ]
          distinguished_name = req_distinguished_name
          x509_extensions = v3_req
          prompt = no

          [ req_distinguished_name ]
          CN = $CERT_NAME
          O = Antonio Musarra
          C = IT

          [ v3_req ]
          keyUsage = critical, digitalSignature
          extendedKeyUsage = codeSigning
          EOF

          openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes -config codesign.cnf -extensions v3_req
          openssl pkcs12 -export -out "$CERT_FILE" -inkey key.pem -in cert.pem -password pass:$CERT_PASS -certpbe AES-256-CBC -keypbe AES-256-CBC
          security create-keychain -p "$CERT_PASS" "$TMP_KEYCHAIN"
          security import "$CERT_FILE" -f pkcs12 -k "$TMP_KEYCHAIN" -P "$CERT_PASS" -T /usr/bin/codesign
          security set-keychain-settings "$TMP_KEYCHAIN"
          security list-keychains -s "$TMP_KEYCHAIN"
          security unlock-keychain -p "$CERT_PASS" "$TMP_KEYCHAIN"
          echo "Certificate imported in temporary keychain for codesign"

      - name: List available certificates for codesign
        run: |
          TMP_KEYCHAIN="$RUNNER_TEMP/codesign.keychain-db"
          security find-identity -p codesigning "$TMP_KEYCHAIN"

      - name: Sign macOS binaries (binari .darwin*)
        run: |
          CERT_NAME="GitHub Actions SelfSign"
          TMP_KEYCHAIN="$RUNNER_TEMP/codesign.keychain-db"
          releaseDir="$RUNNER_TEMP/release"
          for file in $(find "$releaseDir" -type f -name "*darwin*"); do
            echo "Signing $file with identity $CERT_NAME"
            codesign --keychain "$TMP_KEYCHAIN" --force --sign "$CERT_NAME" "$file"
          done

      - name: Re-upload signed assets (clobber)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          tag="${{ github.ref_name }}"
          repo="${{ github.repository }}"
          releaseDir="$RUNNER_TEMP/release"
          files=$(find "$releaseDir" -type f -name "*darwin*")
          if [ -n "$files" ]; then
            gh release upload "$tag" $files --repo "$repo" --clobber
          else
            echo "No macOS binaries found for upload"
          }
      - name: Delete temporary keychain
        if: always()
        run: |
          TMP_KEYCHAIN="$RUNNER_TEMP/codesign.keychain-db"
          security delete-keychain "$TMP_KEYCHAIN"
